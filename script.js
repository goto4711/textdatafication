document.addEventListener('DOMContentLoaded', () => {
    const processBtn = document.getElementById('processBtn');
    const processEmbeddingsBtn = document.getElementById('processEmbeddingsBtn');
    const doc1 = document.getElementById('doc1');
    const doc2 = document.getElementById('doc2');
    const doc3 = document.getElementById('doc3');
    const stopwordsInput = document.getElementById('stopwords');
    const output = document.getElementById('output');
    const embeddingsOutput = document.getElementById('embeddings-output');

    function processDocuments() {
        output.style.display = 'block';
        embeddingsOutput.style.display = 'none';

        const documents = [doc1.value, doc2.value, doc3.value];
        const stopwords = stopwordsInput.value.toLowerCase().split(',').map(word => word.trim());
        
        const allWords = documents.join(' ').toLowerCase().match(/\b(\w+)\b/g) || [];
        const filteredWords = allWords.filter(word => !stopwords.includes(word));
        const vocabulary = [...new Set(filteredWords)].sort();

        let outputHtml = '<h3>Vocabulary (Dictionary):</h3>';
        outputHtml += `<div class="vocabulary">${vocabulary.join(', ')}</div>`;
        outputHtml += '<h3>Term Frequency Vectors:</h3>';
        outputHtml += '<div class="table-container"><table>';
        outputHtml += '<tr><th>Document</th>';
        vocabulary.forEach(word => {
            outputHtml += `<th>${word}</th>`;
        });
        outputHtml += '</tr>';

        documents.forEach((doc, index) => {
            const words = doc.toLowerCase().match(/\b(\w+)\b/g) || [];
            const docWords = words.filter(word => !stopwords.includes(word));
            const vector = vocabulary.map(vocabWord => {
                return docWords.reduce((count, docWord) => count + (docWord === vocabWord ? 1 : 0), 0);
            });
            outputHtml += `<tr><td>Doc ${index + 1}</td>`;
            vector.forEach(val => {
                outputHtml += `<td class="${val > 0 ? 'positive' : 'zero'}">${val}</td>`;
            });
            outputHtml += '</tr>';
        });

        outputHtml += '</table></div>';
        output.innerHTML = outputHtml;
    }

    function processEmbeddings() {
        output.style.display = 'none';
        embeddingsOutput.style.display = 'block';

        const documents = [doc1.value, doc2.value, doc3.value];
        const stopwords = stopwordsInput.value.toLowerCase().split(',').map(word => word.trim());
        const embeddingDim = 5; // Example dimension

        let outputHtml = '<h3>Term Embeddings per Document (Simulated):</h3>';
        outputHtml += '<p>These are simulated embeddings for each term in the vocabulary, shown for each document. In a real application, these vectors would be generated by a neural network, capturing the semantic meaning of the terms.</p>';

        documents.forEach((doc, docIndex) => {
            const words = doc.toLowerCase().match(/\b(\w+)\b/g) || [];
            const docWords = [...new Set(words.filter(word => !stopwords.includes(word)))].sort();

            const docColors = ['blue', 'red', 'green'];
            outputHtml += `<div class="document-embedding"><h4 style="color: ${docColors[docIndex]};">Document ${docIndex + 1}</h4>`;
            outputHtml += '<div class="table-container"><table>';
            outputHtml += '<tr><th>Term</th>';
            for (let i = 1; i <= embeddingDim; i++) {
                outputHtml += `<th>Dim ${i}</th>`;
            }
            outputHtml += '</tr>';

            docWords.forEach(word => {
                const hash = word.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                const random = new Math.seedrandom(hash);
                const embedding = Array.from({length: embeddingDim}, () => (random() * 2 - 1).toFixed(4));

                outputHtml += `<tr><td>${word}</td>`;
                embedding.forEach(val => {
                    outputHtml += `<td>${val}</td>`;
                });
                outputHtml += '</tr>';
            });

            outputHtml += '</table></div></div>';
        });

        embeddingsOutput.innerHTML = outputHtml;

        init3DVisualization();
    }

    processBtn.addEventListener('click', processDocuments);
    processEmbeddingsBtn.addEventListener('click', processEmbeddings);

    // Initial processing on page load
    processDocuments();

    function init3DVisualization() {
        const container = document.getElementById('3d-visualization');
        container.innerHTML = '<h3>3D Document Layers</h3>';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / 400, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, 400);
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040); // soft white light
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        const colors = [0x0000ff, 0xff0000, 0x00ff00]; // Blue, Red, Green
        const documents = [doc1.value, doc2.value, doc3.value];
        const boxDepth = 0.1; // Thickness of the document layers
        const spacing = 0.2; // Spacing between layers

        for (let i = 0; i < 3; i++) {
            const geometry = new THREE.BoxGeometry(5, 2, boxDepth); // Width, Height, Depth
            const material = new THREE.MeshStandardMaterial({ color: colors[i], transparent: true, opacity: 0.7 });
            const box = new THREE.Mesh(geometry, material);
            box.position.z = (i * (boxDepth + spacing)) - (1 * (boxDepth + spacing)); // Layer them along Z-axis
            scene.add(box);
        }

        camera.position.z = 5; // Move camera back to see layers
        camera.position.y = 0; // Center the camera vertically
        camera.position.x = 0; // Center the camera horizontally

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    }
});